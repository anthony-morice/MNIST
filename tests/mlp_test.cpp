#include <gtest/gtest.h>
#include <mlp.h>
#include <opencv2/core/mat.hpp>
#include <opencv2/highgui.hpp>
#include <vec2df.h>
#include <cstdlib>
#include <iostream>
#include <vector>

#define EPS 0.00001

::testing::AssertionResult NEAR_FLOAT_EQ(float a, float b, float eps) {
  if(std::fabs(a - b) < eps)
    return ::testing::AssertionSuccess();
  else
    return ::testing::AssertionFailure()
      << a << " is not within " << eps << " of " << b;
} // NEAR_FLOAT_EQ()

class MLPTest : public ::testing::Test {
  public: 
    void SetUp() override {
      model = new MLP(20, 10, 5);
      model->save_weights("mlp-test_weights.xml");
      cv::FileStorage fs("mlp-test_weights.xml", cv::FileStorage::READ);
      cv::Mat w1;
      cv::Mat w2;
      cv::Mat b1;
      cv::Mat b2;
      fs["w1"] >> w1;
      fs["w2"] >> w2;
      fs["b1"] >> b1;
      fs["b2"] >> b2;
      fs.release();
      this->w1 = vec2df(w1.size[0] * w1.size[1], (float*) w1.data);
      this->w1.shape = {w1.size[0], w1.size[1]};
      this->w2 = vec2df(w2.size[0] * w2.size[1], (float*) w2.data);
      this->w2.shape = {w2.size[0], w2.size[1]};
      this->b1 = vec2df(b1.size[0] * b1.size[1], (float*) b1.data);
      this->b1.shape = {b1.size[0], b1.size[1]};
      this->b2 = vec2df(b2.size[0] * b2.size[1], (float*) b2.data);
      this->b2.shape = {b2.size[0], b2.size[1]};
      in1 = vec2df(1, 20);
      for (int i = 0; i < 20; i++)
        in1.at(i) = float(i + 1);
      y1 = vec2df(1, 10);
      y1.zeros_fill();
      y1.at(2) = 1.0f;
    } // SetUp()

    void TearDown() override {
      delete model;
      std::system("rm ./mlp-test_weights.xml");
    } // TearDown()

  protected:
    MLP* model;
    vec2df w1, w2, b1, b2;
    vec2df in1, y1;
}; // Vector2DTest

/*******************************************************************************
 * Test Cases
 ******************************************************************************/

TEST_F(MLPTest, ConstructorTests) {
  std::pair<int, int> pw1 = {10,20};
  std::pair<int, int> pw2 = {5,10};
  std::pair<int, int> pb1 = {1,10};
  std::pair<int, int> pb2 = {1,5};
  EXPECT_EQ(w1.get_shape(), pw1) << "MLP - incorrect w1 shape initialization ";
  EXPECT_EQ(w2.get_shape(), pw2) << "MLP - incorrect w2 shape initialization ";
  EXPECT_EQ(b1.get_shape(), pb1) << "MLP - incorrect b1 shape initialization ";
  EXPECT_EQ(b2.get_shape(), pb2) << "MLP - incorrect b2 shape initialization ";
} // ConstructorTests

TEST_F(MLPTest, MathTests) {
	// init weight and bias
  std::vector<float> vfb = 
			 {5.1059e-02, 0.0000e+00, 0.0000e+00, 2.6020e-02, 8.8626e-01, 3.5871e-02,
        0.0000e+00, 3.4401e-04, 0.0000e+00, 0.0000e+00};
  std::vector<std::vector<float>> vfw =
			 {{5.1059e-02, 1.0212e-01, 1.5318e-01, 2.0424e-01, 2.5530e-01, 3.0636e-01,
         3.5742e-01, 4.0847e-01, 4.5953e-01, 5.1059e-01, 5.6165e-01, 6.1271e-01,
         6.6377e-01, 7.1483e-01, 7.6589e-01, 8.1695e-01, 8.6801e-01, 9.1907e-01,
         9.7013e-01, 1.0212e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {2.6020e-02, 5.2040e-02, 7.8060e-02, 1.0408e-01, 1.3010e-01, 1.5612e-01,
         1.8214e-01, 2.0816e-01, 2.3418e-01, 2.6020e-01, 2.8622e-01, 3.1224e-01,
         3.3826e-01, 3.6428e-01, 3.9030e-01, 4.1632e-01, 4.4234e-01, 4.6836e-01,
         4.9438e-01, 5.2040e-01},
        {8.8626e-01, 1.7725e+00, 2.6588e+00, 3.5450e+00, 4.4313e+00, 5.3176e+00,
         6.2038e+00, 7.0901e+00, 7.9764e+00, 8.8626e+00, 9.7489e+00, 1.0635e+01,
         1.1521e+01, 1.2408e+01, 1.3294e+01, 1.4180e+01, 1.5066e+01, 1.5953e+01,
         1.6839e+01, 1.7725e+01},
        {3.5871e-02, 7.1743e-02, 1.0761e-01, 1.4349e-01, 1.7936e-01, 2.1523e-01,
         2.5110e-01, 2.8697e-01, 3.2284e-01, 3.5871e-01, 3.9459e-01, 4.3046e-01,
         4.6633e-01, 5.0220e-01, 5.3807e-01, 5.7394e-01, 6.0981e-01, 6.4568e-01,
         6.8156e-01, 7.1743e-01},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {3.4401e-04, 6.8803e-04, 1.0320e-03, 1.3761e-03, 1.7201e-03, 2.0641e-03,
         2.4081e-03, 2.7521e-03, 3.0961e-03, 3.4401e-03, 3.7841e-03, 4.1282e-03,
         4.4722e-03, 4.8162e-03, 5.1602e-03, 5.5042e-03, 5.8482e-03, 6.1922e-03,
         6.5362e-03, 6.8803e-03},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00}};
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 20; j++)
      w1.at(i,j) = vfw[i][j];
  } // for 
  for (int i = 0; i < 10; i++)
    b1.at(i) = vfb[i];
	// verify fc --> a1
  std::vector<float> val = 
		{6.3549, -3.1077, -0.1472,  5.6808,  9.2090,  6.0019, -7.6314,  1.3549, -6.0272, -8.8823};
  vec2df a1 = MLP::fc(in1, w1, b1);
  for (int i = 0; i < 10; i++)
    NEAR_FLOAT_EQ(a1.at(i), val[i], EPS) << "MLP - incorrect fc res at " << i;
	// verify relu --> f1
  vec2df f1 = MLP::relu(a1);
  val = {6.3549, 0.0000, 0.0000, 5.6808, 9.2090, 6.0019, 0.0000, 1.3549, 0.0000, 0.0000};
  for (int i = 0; i < 10; i++)
    NEAR_FLOAT_EQ(f1.at(i), val[i], EPS) << "MLP - incorrect relu res at " << i;
	// verify loss_cross_entropy_softmax --> loss, dl_dy
  auto [loss, dl_dy] = MLP::loss_cross_entropy_softmax(f1, y1);
  NEAR_FLOAT_EQ(loss, 3.7229, EPS);
  val = {5.1059e-02,  8.8749e-05, -9.9991e-01,  2.6020e-02,  8.8626e-01,
				 3.5871e-02,  8.8749e-05,  3.4401e-04,  8.8749e-05,  8.8749e-05};
  for (int i = 0; i < 10; i++)
    NEAR_FLOAT_EQ(dl_dy.at(i), val[i], EPS) << "MLP - incorrect dl_dy val at " << i;
	// verify relu_backward --> dl_da1
  vec2df dl_da1 = MLP::relu_backward(dl_dy, a1, f1);
  val = {5.1059e-02, 0.0000e+00, 0.0000e+00, 2.6020e-02, 8.8626e-01, 3.5871e-02,
        0.0000e+00, 3.4401e-04, 0.0000e+00, 0.0000e+00};
  for (int i = 0; i < 10; i++)
    NEAR_FLOAT_EQ(dl_da1.at(i), val[i], EPS) << "MLP - incorrect dl_da1 val at " << i;
	// verify fc_backward --> dl_dx, dl_dw1, dl_db1
  auto [dl_dx, dl_dw1, dl_db1] = MLP::fc_backward(dl_da1, in1, w1, b1, a1);
  val = {5.1059e-02, 0.0000e+00, 0.0000e+00, 2.6020e-02, 8.8626e-01, 3.5871e-02,
        0.0000e+00, 3.4401e-04, 0.0000e+00, 0.0000e+00};
  for (int i = 0; i < 10; i++)
    NEAR_FLOAT_EQ(dl_db1.at(i), val[i], EPS) << "MLP - incorrect dl_db1 val at " << i;
  std::vector<std::vector<float>> val_2d = 
			 {{5.1059e-02, 1.0212e-01, 1.5318e-01, 2.0424e-01, 2.5530e-01, 3.0636e-01,
         3.5742e-01, 4.0847e-01, 4.5953e-01, 5.1059e-01, 5.6165e-01, 6.1271e-01,
         6.6377e-01, 7.1483e-01, 7.6589e-01, 8.1695e-01, 8.6801e-01, 9.1907e-01,
         9.7013e-01, 1.0212e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {2.6020e-02, 5.2040e-02, 7.8060e-02, 1.0408e-01, 1.3010e-01, 1.5612e-01,
         1.8214e-01, 2.0816e-01, 2.3418e-01, 2.6020e-01, 2.8622e-01, 3.1224e-01,
         3.3826e-01, 3.6428e-01, 3.9030e-01, 4.1632e-01, 4.4234e-01, 4.6836e-01,
         4.9438e-01, 5.2040e-01},
        {8.8626e-01, 1.7725e+00, 2.6588e+00, 3.5450e+00, 4.4313e+00, 5.3176e+00,
         6.2038e+00, 7.0901e+00, 7.9764e+00, 8.8626e+00, 9.7489e+00, 1.0635e+01,
         1.1521e+01, 1.2408e+01, 1.3294e+01, 1.4180e+01, 1.5066e+01, 1.5953e+01,
         1.6839e+01, 1.7725e+01},
        {3.5871e-02, 7.1743e-02, 1.0761e-01, 1.4349e-01, 1.7936e-01, 2.1523e-01,
         2.5110e-01, 2.8697e-01, 3.2284e-01, 3.5871e-01, 3.9459e-01, 4.3046e-01,
         4.6633e-01, 5.0220e-01, 5.3807e-01, 5.7394e-01, 6.0981e-01, 6.4568e-01,
         6.8156e-01, 7.1743e-01},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {3.4401e-04, 6.8803e-04, 1.0320e-03, 1.3761e-03, 1.7201e-03, 2.0641e-03,
         2.4081e-03, 2.7521e-03, 3.0961e-03, 3.4401e-03, 3.7841e-03, 4.1282e-03,
         4.4722e-03, 4.8162e-03, 5.1602e-03, 5.5042e-03, 5.8482e-03, 6.1922e-03,
         6.5362e-03, 6.8803e-03},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00},
        {0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,
         0.0000e+00, 0.0000e+00}};
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 20; j++)
			NEAR_FLOAT_EQ(dl_dw1.at(i,j), val_2d[i][j], EPS) << "MLP - incorrect dl_dw1 val at " << i << ", " << j;
  } // for 
	val = {-0.0788, -0.1926, -0.0558, -0.1205,  0.1692,  0.1932,  0.1027, -0.0289,
        -0.1888,  0.0234, -0.0825,  0.0021, -0.1001, -0.0109,  0.1147,  0.2001,
         0.1575, -0.0957,  0.1405,  0.1399};
  for (int i = 0; i < 20; i++)
    NEAR_FLOAT_EQ(dl_dx.at(i), val[i], EPS) << "MLP - incorrect dl_dx val at " << i;
} // MathTests

